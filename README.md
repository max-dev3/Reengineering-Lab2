# Пропозиції для рефакторингу 

## 1. Використання Map для підрахунку частоти слів
Замість вкладених циклів для підрахунку частоти слів варто використовувати Map, що дозволить зберігати слова як ключі та їх частоту як значення, спрощуючи логіку коду.

## 2. Використання StringBuilder замість конкатенації
Замість того, щоб використовувати конкатенацію рядків у циклах, слід застосувати StringBuilder для підвищення продуктивності та уникнення створення зайвих об'єктів рядків.

## 3. Видалення зайвих змінних
Замість створення окремих масивів для збереження унікальних слів і їх частот, можна використовувати одну структуру даних, таку як Map, для зберігання як слів, так і їх частот.

## 4. Сортування та фільтрація через Stream API
Для сортування та фільтрації даних краще використовувати Stream API, що робить код коротшим і зрозумілішим, порівняно з ручним сортуванням і фільтрацією за допомогою циклів.

## 5. Створення окремих методів для логіки
Виділив окремі частини коду (очищення тексту, підрахунок частоти слів) в окремі методи, щоб покращити структурованість і читабельність коду.

## 6. Використання Locale.ENGLISH замість Locale.ROOT
Замість Locale.ROOT краще використовувати Locale.ENGLISH для роботи з текстом, який написаний англійською мовою, оскільки це більш конкретний варіант.

## 7. Використання Streams для підрахунку слів
Streams дозволяють простіше і швидше підраховувати кількість слів у тексті, замінюючи вкладені цикли.

## 8. Оптимізація пошуку слів і точності алгоритму
У попередньому коді деякі поширені слова (наприклад, "the") не враховувалися. Під час рефакторингу цей недолік був виправлений, що підвищило точність алгоритму.

## 9. Додавання коментарів до коду
Код було доповнено коментарями, щоб було легше зрозуміти, що відбувається в кожному з методів та етапів обробки даних.

## 10. Виставлення правильних пробілів і табуляцій
Було виправлено розташування пробілів і табуляцій для підвищення читабельності коду та його відповідності стандартам оформлення.

# Результати оптимізації підрахунку слів

## Досягнення
Процес рефакторингу призвів до значного покращення продуктивності як за часом виконання, так і за використанням пам'яті. Впровадження оптимізацій, таких як використання Stream для підрахунку частоти слів та уникнення зайвих операцій, показали такі результати:

### Основні покращення:
1. **Час виконання**:
   - До рефакторингу: Неоптимізована версія коду виконувалася за **2502 мс**.
   - Після рефакторингу: Оптимізована версія зменшила час виконання до **206 мс**.

2. **Використання пам'яті**:
   - До рефакторингу: Збільшення пам'яті склало **27 MB** у неоптимізованій версії.
   - Після рефакторингу: Використання пам'яті було зменшено до **15 MB** у оптимізованій версії.

## Порівняння використання пам'яті та часу виконання:

### До рефакторингу:
![image](https://github.com/user-attachments/assets/8b1ca147-7ed5-4df1-ab94-ed07bc16a26d)

### Після рефакторингу:
![image](https://github.com/user-attachments/assets/cf27f1ea-d1c6-4a64-8edd-4a40f3467a98)


### Підсумок змін:
- *Покращена ефективність*: Використання Streams API дозволило швидше виконувати підрахунок частоти слів, виключивши необхідність вкладених циклів.
- *Зменшене використання пам'яті*: Завдяки оптимізації логіки обробки рядків та використанню ефективних структур даних, рефакторизований код зменшив навантаження на пам'ять приблизно на 44%.

